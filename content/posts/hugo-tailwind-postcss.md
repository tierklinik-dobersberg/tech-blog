---
title: "Setting up a static site using Hugo, Tailwind and PostCSS"
date: 2021-11-01T09:47:03+01:00
draft: false
allow_comments: yes
tags: [hugo, tailwind, linux]
---

This post is going to describe how to setup a static site using Hugo, Tailwind
and PostCSS. In addition, we will add the typography plugin of Tailwind so your
posts will look awesome right from the beginning.

<!--more-->

The setup described here is the same one use for this site and
has been documented while creating it.

## Introduction

### Jekyll 

At the time of writing the website of the Veterinary Clinic is created using [Jekyll](https://jekyllrb.com/).
Jekyll is a static website generator that takes a bunch of Markdown files, a theme and then renders
the website into a set of static files that can simply be served by any webserver without needing a
more complicated backend. 

Jekyll itself is created using Ruby and is quite popular because of the tight integration into
Github. You can just create a plain Jekyll site in a repository and Github will render your webpage.
This feature is called [Github Pages](https://pages.github.com/).

### Hugo

Hugo basically serves the same purpose as Jekyll. It takes a bunch of Markdown files and renders them
to a static webpage while applying a theme to your files. In contrast to Jekyll, Hugo is written in
[Go](https://golang.org) and uses the Go templating language (from the `text/template` and `html/template`).

### Why migrating to Hugo?

So one might ask why I even bother to write this post when I already have a static website running using
Jekyll? There are multiple aspects to this question while for me there are mostly 4 points that convinced
me to setup a  static website build using Hugo:

- **Self-Hosting**  
  Since I'm hosting the websites on our Nomad cluster I don't need the tight integration
  with Github Pages. I prefer self-hosting for clinic related content for privacy and
  data regulation reasons. It also allows me to keep our privacy policy short - I just
  don't do any user tracking.

- **Performance**  
  Hugo builds static websites a magnitude faster than Jekyll. I guess I could also improve
  the build speed of Jekyll but I don't want to invest lot's of time for that. I mainly care
  about the performance because I'm building the website automatically in our Nomad cluster
  whenever I push a new commit to the staging or master branch of the Github repository.

- **Golang and the Template Language**  
  I'm a huge fan and user of Golang - I'm programming nearly every day using it - and also
  like the templating language that's built into the standard lib of 
  [Go](https://pkg.go.dev/html/template). In contrast, I just don't like Ruby.
  I've worked on some Ruby based [Metasploit](https://www.metasploit.com/) modules some
  years ago and just could't make friends with it. 

- **Dependencies**  
  While the functionality of Jekyll can easily be extended using Ruby gems I hate fiddling
  around with `bundler` and trying to get my ruby setup working. Hugo instead comes with
  batteries included and provides almost all features I needed to manually add to Jekyll.
  Also, Hugo supports a module system that uses the dependency management of 
  Go - [Go Modules](https://go.dev/blog/using-go-modules) - under the hood and I'm already
  familiar with that (and really like the approach).

So, let's get started!

## Setting up the site

First of all we will need to install hugo on our local machine. Since I'm running on [Archlinux](https://archlinux.org)
and use `yay` as an [AUR](https://aur.archlinux.org) helper that's very straight forward:

```bash
$ yay -S hugo-git
```

Note that I normally use the `-git` version locally as it contains the latest bugfixes and features.

For building the site in production I'm going to create a docker container that can get scheduled
on our Nomad cluster using a specific version of Hugo - but that's something for another post. 

Now that we have hugo installed we can create a new site and initialize a git repository for version
control:

```bash
hugo new site tech-blog
$ cd tech-blog && git init .
```

I'm not going to describe all the files that are generated by Hugo as there's an excellent
[documentation available](https://gohugo.io/getting-started/directory-structure/) on the
gohugo.io website.


## Tailwind and PostCSS

[Tailwind CSS](https://tailwindcss.com) is CSS framework for building websites that encourages
constant use of your design system. On their website, TailwindCSS is described as:

> A utility-first CSS framework packed with classes like flex, pt-4, text-center and rotate-90
> that can be composed to build any design, directly in your markup.

While it might feel a bit cumbersome to work with at the beginning I really like the approach it
takes and using their utility classes starts to feel natural soon. Although Tailwind ships a
beautiful default theme and color palette it's easy to modify the theme, create new utilities
or use plugins.

For integration into the build process of a website Tailwind relies on PostCSS, a CSS pre-processor
to modify, extend or otherwise manipulate your CSS during the build process. PostCSS itself is only
the pre-processor while the actual processing is done by PostCSS plugins - and there are lot's of
them. Tailwind itself is also implemented as a PostCSS plugin.

The nice thing here is that Hugo has native support to use PostCSS in it's
[resource pipelines](https://gohugo.io/hugo-pipes/) using `resources.PostCSS`. 

### A note on SASS

SASS - Syntactically Awesome Style Sheets - is a "professional grade" CSS extension that adds a lot of
features to normal CSS. It supports nested declarations, variables, mixins and more. During the build
processes of your website all SASS code is compiled to plain CSS.

While I'm used to write SASS for styling I decided to use plain PostCSS for this project and make use
of some of the awesome PostCSS plugins to add support for imports and nesting. I don't need other
features like mixins or variables because those use-cases can be achieved using custom Tailwind
utilities and the `@apply` rule as well. 

### Installing dependencies

For Tailwind and PostCSS you need `nodejs` and `npm` installed. On Linux there should be some matching
packages in your distribution's package repositories. For Archlinux a simple `pacman -S nodejs npm` is
enough.

Hugo expected PostCSS and all plugins to be installed locally. To avoid installing them globally on your
machine we'll setup a npm package directly inside the site directory. Answer all questions from npm as
you like. You don't need to care about the entrypoint script.

```bash
npm init . 
```

Next, let's install all of our dependencies. That is, PostCSS itself as well as the plugins and Tailwind:

```bash
npm install --save-dev    \
  postcss                 \ # This is the PostCSS processor itself
  postcss-cli             \ # A cli tool to invoke the processor
  postcss-import          \ # Adds support for @import statements
  postcss-nested          \ # Adds support for nested declarations 
  postcss-purgecss        \ # Required for Tailwind's purge feature
  autoprefixer            \ # Automatically add vendor prefixes
  tailwindcss             \ # This is TailwindCSS itself
  @tailwindcss/typography \ # The Typography plugin for tailwind
```

NPM will update the `package.json` file with those dependencies and install them into the `node_modules/`
folder. The next time - or on a different machine -  you only need to call `npm install` to install all
dependencies.

### Configuring PostCSS

PostCSS is configured using a Javascript file and Hugo searches for this configuration in a file called
`postcss.config.js`. Here's the content of that file:

```javascript
module.exports = {
	plugins: [ 
		require('postcss-import'),
		require('tailwindcss')('./tailwind.config.js'),
		require('postcss-nested'),
		// eslint-disable-next-line no-process-env
		...(process.env.HUGO_ENVIRONMENT === 'production'
          ? [ require('autoprefixer') ]
          : []
        )
	]
};
```

That file should be very much self explanatory. We just defined all plugins by adding them to the
`plugins` array. Note that we only add the `autoprefixer` if Hugo is building the site for production.
This keeps the CSS more readable while you're working on your site. 

### Configuring Tailwind

As you can see in the PostCSS configuration above a file called `tailwind.config.js` is referenced.
This file is going to hold the Tailwind configuration. Let's go a head and create it with the
following content:

```javascript
const theme = require('tailwindcss/defaultTheme');
const colors = require('tailwindcss/colors')

// Delete lightBlue from tailwind colors palette as it has been
// deprecated and renamed to `sky`. This otherwise triggers a
// warning that is rendered into the final CSS and will break
// your site.
delete(colors['lightBlue']); 

module.exports = {
	purge: {
		enabled: process.env.HUGO_ENVIRONMENT === 'production',
		content: [
			'./hugo_stats.json',
			'./layouts/**/*.html',
		],
		extractors: [
			{
				extractor: (content) => {
					let els = JSON.parse(content).htmlElements;
					return els.tags.concat(els.classes, els.ids);
				},
				extensions: ['json']
			},
		],
		mode: 'all',

	},
	plugins: [
    // Add other tailwind plugins here as you like
    require('@tailwindcss/typography');
  ]
};
```

Tailwind has support to purge unused CSS when optimizing the site for production. In the above
configuration file we tell Tailwind to search for used utilities and class names in all HTML files
under the `layout/` folder. We also configure it to read the file `hugo_stats.json` and parse it
with the configured `json` extractor. This file can be created by Hugo when building the website.
See [here](https://tailwindcss.com/docs/optimizing-for-production) for more information about the
purge feature and how to write "purgeable" HTML.

## Setting up Hugo

Now that we have PostCSS and Tailwind configured it's time to configure Hugo and our site to
actually use them.

For that, we first need to tell Hugo to write the `hugo_stats.json` file by adding the following
configuration to `config.toml`. 

```toml
# Other Hugo configuration

[build]
  # Used by PurgeCSS
  writeStats = true
```

Next we will create an `assets` folder that will hold our style definitions;

```bash
mkdir -p assets
```

In this folder, create a file called `styles.css` with the following content:

```scss
@import 'tailwindcss/base.css';
@import 'tailwindcss/components.css';
@import 'tailwindcss/utilities.css';

@layer components {
  .btn {
    @apply text-gray-800 px-4 py-2 border border-gray-500 rounded bg-white hover:bg-gray-100;
  }
}
```

That will import all the tailwind utilities and components. The `@layer` here is just an example of
how to create custom tailwind components. See [Extracting Components](https://tailwindcss.com/docs/extracting-components)
from the Tailwind documentation for more information.

The last step to get everything working together is to create the base HTML template files that Hugo will use:

Create the file `baseof.html` in `layouts/_default/`. If the directory does not exist just go ahead and create
it. Then place the following content into `baseof.html`:

```go-html-template
<!DOCTYPE html>
<html lang="en">

<head>
  {{ $options := dict "inlineImports" true }}
  {{ $styles := resources.Get "styles.css" | resources.PostCSS $options }}

  {{ if hugo.IsProduction }}
  {{ $styles = $styles | minify | fingerprint | resources.PostProcess }}
  {{ end }}

  <style crossorigin="anonymous" media="all" type="text/css" integrity="{{ $styles.Data.Integrity }}">
      {{ $styles.Content | safeCSS }}
  </style>
</head>

<body>
  <main class="w-full">
    {{ block "main" . }}{{ end }}
  </main>
</body>

</html>
```

The above template uses a [Hugo Pipe](https://gohugo.io/hugo-pipes/introduction/) that transforms the
`styles.css` resource using PostCSS.

```go-html-template
{{ $styles := resources.Get "styles.css" | resources.PostCSS $options }}
```

When Hugo is building the site for production it will also minify the CSS file and create a fingerprint
for HTML sub-resource integrity (SRI):

```go-html-template
  {{ if hugo.IsProduction }}
  {{ $styles = $styles | minify | fingerprint | resources.PostProcess }}
  {{ end }}
```

Finally, it will embed the resulting CSS directly. This is useful as the browser does not need to do an
extra round-trip for loading the style definition and will increase page load speed.

Finally, create the file `layouts/_default/single.html` that will be used to render most of your articles:

```go-html-template
{{ define "main" }}
<div class="container flex justify-center px-4 pt-4 mb-4 lg:mx-auto md:mb-8 lg:mb-12 md:pt-6 lg:pt-8">
  <article class="prose">
    {{ .Content }}
  </article>
</div>
{{ end }}
```

The `prose` class comes from Tailwind's [Typography](//github.com/tailwindlabs/tailwindcss-typography) plugin and ensures your markdown content is rendered
in a beautiful fashion. 

That's all for now. I hope this post will be useful to others. Feel free to drop a comment below!
 